<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Three.js Hello World</title>
        <style>
            body { margin: 0;}
            canvas {display: block;}
        </style>
    </head>
    <body>
        <script src="./node_modules/ccapture.js/build/CCapture.all.min.js"></script>
        <script type="module">
            import * as THREE from "./node_modules/three/build/three.module.js"; 
            import { WEBGL } from "./node_modules/three/examples/jsm/WebGL.js";
            import { OrbitControls } from "./node_modules/three/examples/jsm/controls/OrbitControls.js";

            function init() {
                var capturer = new CCapture( { format: 'webm', workersPath: './node_modules/ccapture.js/src/'} );
                var clock = new THREE.Clock();
                
                var scene = new THREE.Scene();
                var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

                var renderer = new THREE.WebGLRenderer();
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);
                
                var controls = new OrbitControls(camera, renderer.domElement);

                var planeGeometry = new THREE.PlaneBufferGeometry(2, 2);
                var boxGeometry = new THREE.BoxGeometry();
                var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
                
                let vertexShader = new  XMLHttpRequest();
                vertexShader.open('GET', './shaders/vertex.glsl', false);
                vertexShader.send(null);
                if(vertexShader.status >= 200 && vertexShader.status < 300){
                    vertexShader = vertexShader.responseText;
                }

                let fragmentShader = new  XMLHttpRequest();
                fragmentShader.open('GET', './shaders/fragment.glsl', false);
                fragmentShader.send(null);
                if(fragmentShader.status >= 200 && fragmentShader.status < 300){
                    fragmentShader = fragmentShader.responseText;
                }

                var shaderUniforms = {
                    iTime: {value: 0},
                    iResolution: {value: new THREE.Vector2(window.innerWidth, window.innerHeight)},
                };

                var shaderMaterial = new THREE.ShaderMaterial({
                    uniforms: shaderUniforms,
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader
                });

                var plane = new THREE.Mesh(planeGeometry, shaderMaterial);
                plane.x = -1;
                plane.y = -1;
                scene.add( plane ); 

                var box = new THREE.Mesh(boxGeometry, material);
                scene.add(box);

                camera.position.set(-2, 27, 25);
                camera.up.set( 0, 1, 0 );
                camera.lookAt(0.0, 0.0, 0.0);
                camera.updateProjectionMatrix();
                controls.update();

                var captureRunning = true;
                var startTime = -1;
                var rotation = 0;
                var rotationRadius = 35;
                var period = 10;
                
                function render(time)  {
                    if(startTime < 0){
                        startTime = time * 0.001;
                    }

                    requestAnimationFrame( render );

                    var timeSeconds = time * 0.001 - startTime;

                    shaderUniforms.iTime.value = timeSeconds;

                    renderer.render(scene, camera);

                    capturer.capture( renderer.domElement );

                    camera.position.set(Math.cos(timeSeconds*Math.PI*2 / period) * rotationRadius, 20, Math.sin(timeSeconds*Math.PI*2 / period) * rotationRadius);
                    camera.up.set( 0, 1, 0 );
                    camera.lookAt(0.0, 0.0, 0.0);
                    camera.updateProjectionMatrix();

                    controls.update();

                    if(timeSeconds >= 10 && captureRunning){
                        captureRunning = false;

                        capturer.save();
                        
                        capturer.stop();
                    }
                }

                if(WEBGL.isWebGLAvailable){
                    requestAnimationFrame( render );
                    capturer.start();
                }else{
                    var warning = WEBGL.getWebGLErrorMessage();
                    document.getElementById('container'.appendChild(warning));
                }

                window.addEventListener('resize', function () {
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                });
            }

            window.onload = init;
        </script>
    </body>
</html>